### ▶ 看你能不能猜到这个的结果？

```py
a, b = a[b] = {}, 5
```

**Output:**
```py
>>> a
{5: ({...}, 5)}
```

#### :bulb: 解释:

* 根据Python的赋值语句的[文档](https://docs.python.org/3.7/reference/simple_stmts.html#assignment-statements),赋值语句有如下的格式
  ```
  (target_list "=")+ (expression_list | yield_expression)
  ```
  并且
  > 一个赋值语句会对表达式列表(expression_list)进行求值（这个可以只有一个表达式，也可以多个表达式用逗号分开组成表达式列表，后者最终会表现为元组的形式）并且会将单次的求值结果对象依次从左至右赋值给目标列表(target_list)。

* 在`(target_list "=")+`这个表达式中`+`意味着 **一个或者多个** 目标列表。这上面这个例子中，目标列表是`a,b`和`a[b]`（注意表达式列表永远只有一个，在我们这个例子里是`{}, 5`）。

* 当表达式计算出来后，它的值会被 **从左至右** 依次赋值给目标列表。所以，在上面的例子里，第一次赋值会把`{}, 5`这个元组赋值给`a, b`这个目标列表，这个时候`a = {}` 并且 `b = 5`。

* 现在`a`被赋值成了`{}`，一个可变对象(mutable object)。

* 第二个目标列表是`a[b]`（你可能会认为这种写法会报错，因为我们没有之前并没有定义`a`和`b`，但是没关系，我们刚刚已经给`a`和`b`分别赋值了`{}`和`5`）。

* 现在我们会把元组`({}, 5)`赋值给字典关键为`5`的字典对象（也就是`a[5]`），同时也因此创建了一个循环引用(circular reference)（`{...}`在输出中代表同一个对象`a`已经被引用了）。下面是一个关于引用循环简单点的例子

  ```py
  >>> some_list = some_list[0] = [0]
  >>> some_list
  [[...]]
  >>> some_list[0]
  [[...]]
  >>> some_list is some_list[0]
  True
  >>> some_list[0][0][0][0][0][0] == some_list
  True
  ```
  在我们的例子用也是同样的情况（`a[b][0]`和`a`是指向同一个对象）

* 所以总结一下，我们可以把上面的列子像如下这样拆分
  ```py
  a, b = {}, 5
  a[b] = a, b
  ```
  并且通过`a[b][0]`和`a`是同一个对象来证明确实存在引用循环
  ```py
  >>> a[b][0] is a
  True
  ```

---